import path from 'node:path'

import type {
  AttributeNode,
  DirectiveNode,
  ElementNode,
  TemplateChildNode,
} from '@vue/compiler-core'
import { NodeTypes } from '@vue/compiler-core'
import MagicString from 'magic-string'
import type { Plugin, ResolvedConfig } from 'vite'
import { compileScript, parse, type SFCDescriptor } from 'vue/compiler-sfc'

import {
  generateIslandWrapperCodeJS,
  generateServerComponentCodeJS,
  islandWrapId,
  islandWrapPrefix,
  serverWrapPrefix,
} from '../generate.js'
import { customElementEntryPath, parseId } from '../paths.js'

interface ServerTransformPluginResult {
  plugin: Plugin
  islandPaths: Set<string>
}

function toAbsolutePath(fileName: string, importer: string | undefined): string {
  if (path.isAbsolute(fileName)) {
    return fileName
  }
  if (importer) {
    const importerFileName = parseId(importer).fileName
    return path.resolve(path.dirname(importerFileName), fileName)
  }
  return path.resolve(fileName)
}

/**
 * Vite plugin that transforms Vue SFC imports on the server environment.
 * - Redirects `.vue` imports to server component wrapper virtual modules
 * - Loads server/island wrapper virtual modules with generated code
 * - Rewrites SFC templates containing `v-client:load` directives
 *   to replace components with island wrappers
 * - Collects island component paths for the islands build
 */
export function serverTransformPlugin(): ServerTransformPluginResult {
  const islandPaths = new Set<string>()
  let viteConfig: ResolvedConfig

  const plugin: Plugin = {
    name: 'visle:server-transform',

    enforce: 'pre',

    applyToEnvironment(environment) {
      return environment.name === 'server'
    },

    configResolved(resolvedConfig) {
      viteConfig = resolvedConfig
    },

    buildStart() {
      islandPaths.clear()
    },

    resolveId(id, importer) {
      // Resolve island wrapper virtual module imports (generated by transform)
      if (id.startsWith(islandWrapId)) {
        return '\0' + id
      }

      // Redirect .vue imports to server wrapper virtual modules.
      // Skip when the importer is a wrapper module to avoid infinite recursion.
      const { fileName, query } = parseId(id)

      if (fileName.endsWith('.vue') && !query.vue) {
        const isFromWrapper =
          importer?.startsWith(serverWrapPrefix) || importer?.startsWith(islandWrapPrefix)
        if (!isFromWrapper) {
          const absolutePath = toAbsolutePath(fileName, importer)
          return serverWrapPrefix + absolutePath
        }
      }
    },

    load(id) {
      // Handle virtual JS modules for server wrapping.
      // These use non-.vue IDs to prevent the Vue plugin from processing them
      // and corrupting its shared descriptor cache.
      if (id.startsWith(serverWrapPrefix)) {
        const filePath = id.slice(serverWrapPrefix.length)
        const componentRelativePath = path.relative(viteConfig.root, filePath)
        return generateServerComponentCodeJS(filePath, componentRelativePath)
      }

      if (id.startsWith(islandWrapPrefix)) {
        const filePath = id.slice(islandWrapPrefix.length)
        const componentRelativePath = path.relative(viteConfig.root, filePath)
        const customElementEntryRelativePath = path.relative(
          viteConfig.root,
          customElementEntryPath,
        )
        return generateIslandWrapperCodeJS(
          filePath,
          componentRelativePath,
          customElementEntryRelativePath,
        )
      }
    },

    transform(code, id) {
      const { fileName, query } = parseId(id)

      if (!fileName.endsWith('.vue')) {
        return null
      }

      // Skip sub-requests (e.g., ?vue&type=style) â€” only process plain .vue files
      if (query.vue) {
        return null
      }

      const { descriptor } = parse(code)

      if (!descriptor.template?.ast) {
        return null
      }

      // Build tag-name-to-import-source map from <script setup>
      const importMap = buildImportMap(descriptor, id)

      // Find elements with v-client:load
      const vClientMatches = findVClientElements(descriptor.template.ast.children)

      // Find elements imported from .island.vue files (backward compat)
      const islandFileTags = new Set<string>()
      for (const [tag, source] of importMap.entries()) {
        if (source.endsWith('.island.vue')) {
          islandFileTags.add(tag)
        }
      }
      const vClientOffsets = new Set(vClientMatches.map((n) => n.loc.start.offset))
      const islandFileMatches =
        islandFileTags.size > 0
          ? findElementsByTags(descriptor.template.ast.children, islandFileTags).filter(
              (n) => !vClientOffsets.has(n.loc.start.offset),
            )
          : []

      const matches = [...vClientMatches, ...islandFileMatches]

      if (matches.length === 0) {
        return null
      }

      const s = new MagicString(code)
      const imports: string[] = []

      for (let i = 0; i < matches.length; i++) {
        const node = matches[i]!
        const tag = node.tag
        const wrapperName = `VisleIsland${i}`

        // Check if this is a statically imported component
        const importSource = importMap.get(tag)
        if (!importSource) {
          this.error(
            `v-client:load on "${tag}" is not supported. ` +
              'Only statically imported Vue components are supported.',
          )
          continue
        }

        // Resolve the absolute path of the component and collect for islands build
        const resolvedPath = path.resolve(path.dirname(fileName), importSource)
        islandPaths.add(resolvedPath)

        // Add import for the island wrapper virtual module
        imports.push(`import ${wrapperName} from '${islandWrapId}${resolvedPath}'`)

        // Rewrite the element in the template
        rewriteElement(s, node, wrapperName)
      }

      // Inject imports into <script setup> right after the opening tag
      if (imports.length > 0 && descriptor.scriptSetup) {
        const contentStart = descriptor.scriptSetup.loc.start.offset
        s.appendRight(contentStart, '\n' + imports.join('\n'))
      }

      return {
        code: s.toString(),
        map: s.generateMap({ hires: true }),
      }
    },
  }

  return { plugin, islandPaths }
}

/**
 * Parses import declarations from <script setup> using compileScript
 * to build a tag-name-to-import-source mapping.
 */
function buildImportMap(descriptor: SFCDescriptor, id: string): Map<string, string> {
  const map = new Map<string, string>()

  if (!descriptor.scriptSetup) {
    return map
  }

  const { imports } = compileScript(descriptor, { id })

  if (!imports) {
    return map
  }

  for (const [name, binding] of Object.entries(imports)) {
    if (binding.source.endsWith('.vue')) {
      map.set(name, binding.source)
    }
  }

  return map
}

/**
 * Recursively finds elements with v-client:load directive.
 */
function findVClientElements(children: TemplateChildNode[]): ElementNode[] {
  const results: ElementNode[] = []

  for (const child of children) {
    if (child.type !== NodeTypes.ELEMENT) {
      continue
    }

    const hasVClient = child.props.some(
      (prop: AttributeNode | DirectiveNode) =>
        prop.type === NodeTypes.DIRECTIVE &&
        prop.name === 'client' &&
        prop.arg?.type === NodeTypes.SIMPLE_EXPRESSION &&
        prop.arg.content === 'load',
    )

    if (hasVClient) {
      results.push(child)
    } else if (child.children.length > 0) {
      // Only recurse into children if the parent itself doesn't have v-client:load.
      // A matched parent will be fully rewritten, so collecting its children too
      // would produce overlapping MagicString edits.
      results.push(...findVClientElements(child.children))
    }
  }

  return results
}

/**
 * Recursively finds elements whose tag matches one of the given tags.
 */
function findElementsByTags(children: TemplateChildNode[], tags: Set<string>): ElementNode[] {
  const results: ElementNode[] = []

  for (const child of children) {
    if (child.type !== NodeTypes.ELEMENT) {
      continue
    }

    if (tags.has(child.tag)) {
      results.push(child)
    }

    if (child.children.length > 0) {
      results.push(...findElementsByTags(child.children, tags))
    }
  }

  return results
}

/**
 * Rewrites an element with v-client:load by replacing it
 * with the island wrapper component. The wrapper imports the original
 * component internally and renders it inside <vue-island>.
 * Child content (slots) is preserved and passed through.
 */
function rewriteElement(s: MagicString, node: ElementNode, wrapperName: string): void {
  const start = node.loc.start.offset
  const end = node.loc.end.offset

  const originalSource = s.original.slice(start, end)

  // Build props string (excluding v-client:load)
  const propsStr = buildPropsString(node)

  const tag = node.tag

  let wrapped: string
  if (node.isSelfClosing) {
    wrapped = `<${wrapperName}${propsStr} />`
  } else {
    const childrenContent = extractChildrenContent(originalSource, tag)
    wrapped = `<${wrapperName}${propsStr}>${childrenContent}</${wrapperName}>`
  }

  s.overwrite(start, end, wrapped)
}

/**
 * Builds a props string from element props, excluding v-client:load.
 */
function buildPropsString(node: ElementNode): string {
  const props: string[] = []

  for (const prop of node.props) {
    // Skip v-client:load directive
    if (prop.type === NodeTypes.DIRECTIVE && prop.name === 'client') {
      continue
    }

    props.push(prop.loc.source)
  }

  if (props.length === 0) {
    return ''
  }

  return ' ' + props.join(' ')
}

/**
 * Extracts the children content from an element's source string.
 */
function extractChildrenContent(source: string, tag: string): string {
  // Find the end of the opening tag
  const openTagEnd = findOpenTagEnd(source)
  // Find the start of the closing tag
  const closeTagStart = source.lastIndexOf(`</${tag}`)

  if (openTagEnd === -1 || closeTagStart === -1) {
    return ''
  }

  return source.slice(openTagEnd, closeTagStart)
}

/**
 * Finds the end position of the opening tag (after the `>`).
 */
function findOpenTagEnd(source: string): number {
  let inQuote: string | null = null

  for (let i = 0; i < source.length; i++) {
    const char = source[i]!

    if (inQuote) {
      if (char === inQuote) {
        inQuote = null
      }
      continue
    }

    if (char === '"' || char === "'") {
      inQuote = char
      continue
    }

    if (char === '>') {
      return i + 1
    }
  }

  return -1
}
