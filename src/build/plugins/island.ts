import { readFile } from 'node:fs/promises'
import path from 'node:path'
import { Plugin, ResolvedConfig } from 'vite'

import { ResolvedVisleConfig } from '../config.js'
import {
  generateIslandWrapperCodeJS,
  generateServerComponentCodeJS,
  generateClientVirtualEntryCode,
  generateServerVirtualEntryCode,
  clientVirtualEntryId,
  serverVirtualEntryId,
  serverWrapPrefix,
  islandWrapId,
  islandWrapPrefix,
} from '../generate.js'
import {
  customElementEntryPath,
  virtualCustomElementEntryPath,
  resolveServerComponentIds,
} from '../paths.js'

/**
 * Core Vite plugin for the islands architecture.
 * Resolves and loads virtual entry modules per environment (style, islands, server)
 * and handles island wrapper virtual modules for island wrapper code generation.
 */
export function islandPlugin(config: ResolvedVisleConfig): Plugin {
  let viteConfig: ResolvedConfig

  return {
    name: 'visle:island',

    enforce: 'pre',

    sharedDuringBuild: true,

    configResolved(resolvedConfig) {
      viteConfig = resolvedConfig
    },

    resolveId(id) {
      const envName = this.environment?.name

      // Resolve island wrapper virtual module imports (generated by server-transform plugin)
      if (id.startsWith(islandWrapId)) {
        return '\0' + id
      }

      if (envName === 'style') {
        if (id === clientVirtualEntryId) {
          return clientVirtualEntryId
        }
        return
      }

      if (envName === 'islands') {
        if (id === virtualCustomElementEntryPath) {
          return virtualCustomElementEntryPath
        }
        return
      }

      if (envName === 'server') {
        if (id === serverVirtualEntryId) {
          return serverVirtualEntryId
        }
        return
      }

      // Dev client environment — resolve both virtual entries
      if (id === virtualCustomElementEntryPath) {
        return virtualCustomElementEntryPath
      }

      if (id === clientVirtualEntryId) {
        return clientVirtualEntryId
      }
    },

    load(id) {
      const envName = this.environment?.name

      // Handle virtual JS modules for server wrapping.
      // These use non-.vue IDs to prevent the Vue plugin from processing them
      // and corrupting its shared descriptor cache.
      if (id.startsWith(serverWrapPrefix)) {
        const filePath = id.slice(serverWrapPrefix.length)
        const componentRelativePath = path.relative(viteConfig.root, filePath)
        return generateServerComponentCodeJS(filePath, componentRelativePath)
      }

      if (id.startsWith(islandWrapPrefix)) {
        const filePath = id.slice(islandWrapPrefix.length)
        const componentRelativePath = path.relative(viteConfig.root, filePath)
        const customElementEntryRelativePath = path.relative(
          viteConfig.root,
          customElementEntryPath,
        )
        return generateIslandWrapperCodeJS(
          filePath,
          componentRelativePath,
          customElementEntryRelativePath,
        )
      }

      if (envName === 'style') {
        if (id === clientVirtualEntryId) {
          return generateClientVirtualEntryCode(
            resolveServerComponentIds(path.join(viteConfig.root, config.componentDir)),
          )
        }
        return null
      }

      if (envName === 'islands') {
        if (id === virtualCustomElementEntryPath) {
          return readFile(customElementEntryPath, 'utf-8')
        }
        return null
      }

      if (envName === 'server') {
        if (id === serverVirtualEntryId) {
          return generateServerVirtualEntryCode(
            path.join(viteConfig.root, config.componentDir),
            resolveServerComponentIds(path.join(viteConfig.root, config.componentDir)),
          )
        }

        return null
      }

      // Dev client environment — load both virtual entries
      if (id === clientVirtualEntryId) {
        return generateClientVirtualEntryCode(
          resolveServerComponentIds(path.join(viteConfig.root, config.componentDir)),
        )
      }

      if (id === virtualCustomElementEntryPath) {
        return readFile(customElementEntryPath, 'utf-8')
      }

      return null
    },
  }
}
